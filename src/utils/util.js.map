{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":";;AAAA,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAGpB,QAAA,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC;IAC1C,KAAK;IACL,KAAK,GAAG,EAAE;IACV,OAAO,GAAG,EAAE;IACZ,OAAO,GAAG,EAAE,GAAG,CAAC;IAChB,OAAO,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE;CACxB,CAAC,CAAC;AAMU,QAAA,cAAc,GAAkB,MAAM,CAAC,MAAM,CAAC;IACvD,CAAC,EAAC,CAAC;IACH,CAAC,EAAC,CAAC;IACH,CAAC,EAAC,CAAC;IACH,CAAC,EAAC,CAAC;IACH,CAAC,EAAC,CAAC;CACN,CAAC,CAAC;AAWH;;;GAGG;AACH,SAAgB,cAAc,CAAC,QAAuB;IAClD,IAAI,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;IAClC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAC;QACtB,MAAM,IAAI,KAAK,CAAC,6CAA6C,QAAQ,WAAW,CAAC,CAAC;KACrF;IAED,IAAI,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACrC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,kEAAkE,QAAQ,WAAW,CAAC,CAAC;KAC1G;IAED,MAAM,YAAY,GAAU,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACxD,IAAI,WAAW,GAAU,sBAAc,CAAC,YAAY,CAAC,CAAC;IACtD,MAAM,YAAY,GAAU,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IACnD,MAAM,CAAC,OAAO,WAAW,KAAK,QAAQ,EAAE,kDAAkD,CAAC,CAAC;IAE5F,IAAI,IAAI,GAAG,wBAAgB,CAAC,WAAW,CAAC,GAAG,YAAY,CAAC;IAExD,OAAO,EAAC,IAAI,EAAE,WAAW,EAAE,YAAY,EAAE,IAAI,EAAC,CAAC;AACnD,CAAC;AAnBD,wCAmBC;AAED,SAAS,kBAAkB,CAAC,KAAY;IACpC,IAAG,MAAM,CAAC,IAAI,CAAC,sBAAc,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAC;QAC3C,OAAO,KAAK,CAAC;KAChB;;QAAK,MAAM,IAAI,KAAK,CAAC,mBAAmB,GAAG,KAAK,CAAC,CAAC;AACvD,CAAC","sourcesContent":["const assert = require(\"assert\");\nimport * as Enums from \"../types/enums\";\n\nexport const unitMilliseconds = Object.freeze([\n    60000, //m\n    60000 * 60, //h\n    3600000 * 24, //d\n    3600000 * 24 * 7,\n    3600000 * 24 * 7 * 30, //roughly...\n]);\n\ntype IntervalValues = {\n    [name: string]: number;\n}\n\nexport const validIntervals:IntervalValues = Object.freeze({\n    m:0,\n    h:1,\n    d:2,\n    w:4,\n    M:5\n});\n\n\n\nexport type ExpandedInterval = {\n    unit: number,\n    intervalUnit: string,\n    cost: number\n\n}\n\n/***\n * Separates an interval string into a numeric value and a unit string\n * @param {String} interval\n */\nexport function expandInterval(interval:Enums.Interval):ExpandedInterval{\n    let value = interval.match(/\\d+/);\n    if (!Array.isArray(value)){\n        throw new Error(`failed to extract a numeric interval, was ${interval} correct?`);\n    }\n\n    let unit = interval.match(/[mhdwM]/);\n    if (!Array.isArray(unit)) {\n        throw new Error(`failed to extract a string unit for the interval interval, was ${interval} correct?`);\n    }\n\n    const intervalUnit:string = strToIntervalValue(unit[0]);\n    let unitNumeral:number = validIntervals[intervalUnit];\n    const numericValue:number = parseInt(value[0], 10);\n    assert(typeof unitNumeral === 'number', 'The unit for an interval must be m, h, d, w or M');\n\n    let cost = unitMilliseconds[unitNumeral] * numericValue;\n\n    return {unit: unitNumeral, intervalUnit, cost};\n}\n\nfunction strToIntervalValue(input:string):string{\n    if(Object.keys(validIntervals).includes(input)){\n        return input;\n    }else throw new Error(\"Invalid interval:\" + input);\n}\n\n"]}