{"version":3,"file":"bars.js","sourceRoot":"","sources":["bars.ts"],"names":[],"mappings":";;AAMA,MAAM,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AACjC,MAAM,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC,OAAO,CAAC,CAAC;AACxC,MAAM,EACF,cAAc,GACjB,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AAC7B,MAAM,cAAc,GAAG,GAAG,CAAC;AAO3B,KAAK,UAAU,YAAY,CAAC,OAAmC;IAC3D,IAAI,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;IACtC,IAAI,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAC5B,IAAI,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;IAChC,IAAI,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;IAClC,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAC9B,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAC9B,IAAI,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;IAE9B,MAAM,CAAC,OAAO,SAAS,KAAK,QAAQ,IAAI,SAAS,GAAG,IAAI,CAAC,GAAG,EAAE,EAAE,uDAAuD,CAAC,CAAC;IACzH,MAAM,CAAC,OAAO,OAAO,KAAK,QAAQ,EAAE,0BAA0B,CAAC,CAAC;IAChE,MAAM,CAAC,SAAS,GAAG,OAAO,EAAE,kCAAkC,CAAC,CAAC;IAEhE,yBAAyB;IACzB,IAAI,WAAW,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;IAE3C,IAAI,WAAW,GAAG,wBAAwB,CAAC,SAAS,EAAE,OAAO,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;IAErF,OAAO,cAAc,CAAC,WAAW,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;AAC/E,CAAC;AAED,KAAK,UAAU,cAAc,CAAC,WAAuC,EACvC,MAAc,EACd,QAAkB,EAClB,WAA8B,EAC9B,OAAoC;IAC9D,IAAI,OAAO,GAAkB,EAAE,CAAC;IAChC,KAAK,IAAI,YAAY,IAAI,WAAW,EAAE;QAClC,KAAK,CAAC,aAAa,CAAC,CAAC;QACrB,IAAI,MAAM,GAAG,MAAM,WAAW,CAAC;YAC3B,MAAM,EAAE,MAAM;YACd,QAAQ,EAAE,QAAQ;YAClB,SAAS,EAAE,YAAY,CAAC,KAAK;YAC7B,OAAO,EAAE,YAAY,CAAC,GAAG;YACzB,OAAO,EAAE,GAAG;SACf,CAAC,CAAC;QACH,KAAK,CAAC,sBAAsB,CAAC,CAAC;QAC9B,IAAI,OAAO,EAAC;YACR,MAAM,OAAO,CAAC,MAAM,CAAC,CAAC;SACzB;QACD,KAAK,CAAC,UAAU,CAAC,CAAC;QAClB,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KACpC;IACD,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;AACpC,CAAC;AAED;;;;;;GAMG;AACH,SAAS,wBAAwB,CAAC,SAAiB,EACjB,OAAe,EACf,WAAgB,EAChB,OAAe;IAC7C,6GAA6G;IAC7G,IAAI,WAAW,GAAG,SAAS,CAAC;IAC5B,IAAI,SAAS,GAAG,CAAC,CAAC;IAClB,IAAI,YAAY,GAAG,OAAO,IAAI,cAAc,CAAC;IAC7C,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,OAAO,WAAW,GAAG,OAAO,EAAE;QAC1B,SAAS,GAAG,WAAW,GAAG,WAAW,CAAC,IAAI,GAAG,YAAY,CAAC;QAC1D,OAAO,CAAC,IAAI,CAAC;YACT,KAAK,EAAE,WAAW;YAClB,GAAG,EAAE,SAAS;SACjB,CAAC,CAAC;QACH,WAAW,GAAG,SAAS,CAAC;KAC3B;IACD,OAAO,OAAO,CAAC;AACnB,CAAC;AAGD,MAAM,CAAC,OAAO,GAAG;IACb,YAAY;CACf,CAAC","sourcesContent":["import * as CandleRequest from \"../types/candles-request\";\nimport {CandlesRequest} from \"../types/candles-request\";\nimport Candle from \"../types/candle\";\nimport {FetchHandler} from \"../types/candles-request\";\nimport {Interval} from \"../types/enums\";\n\nconst assert = require(\"assert\");\nconst debug = require(\"debug\")(\"fetch\");\nconst {\n    expandInterval,\n} = require(\"../utils/util\");\nconst defaultMaxBars = 500;\n\ninterface TimeWindow {\n    start: number,\n    end: number\n}\n\nasync function fetchCandles(options: CandleRequest.FetchOptions) {\n    let fetchAction = options.fetchAction;\n    let symbol = options.symbol;\n    let interval = options.interval;\n    let startTime = options.startTime;\n    let endTime = options.endTime;\n    let maxBars = options.maxBars;\n    let handler = options.handler;\n\n    assert(typeof startTime === \"number\" && startTime < Date.now(), \"startTime must be a number less then the current time\");\n    assert(typeof endTime === \"number\", \"endTime must be a number\");\n    assert(startTime < endTime, \"startTime must be before endTime\");\n\n    //understand the interval\n    let intervalObj = expandInterval(interval);\n\n    let timeWindows = calculateCallTimeWindows(startTime, endTime, intervalObj, maxBars);\n\n    return doFetchInSteps(fetchAction, symbol, interval, timeWindows, handler);\n}\n\nasync function doFetchInSteps(fetchAction: CandleRequest.FetchHandler,\n                              symbol: string,\n                              interval: Interval,\n                              timeWindows: Array<TimeWindow>,\n                              handler: CandleRequest.ResultHandler) {\n    let results: Array<Candle> = [];\n    for (let startEndPair of timeWindows) {\n        debug(\"fetching...\");\n        let result = await fetchAction({\n            symbol: symbol,\n            interval: interval,\n            startTime: startEndPair.start,\n            endTime: startEndPair.end,\n            maxBars: 300\n        });\n        debug(\"fetched, handling...\");\n        if (handler){\n            await handler(result);\n        }\n        debug(\"handled.\");\n        results = results.concat(result);\n    }\n    return Promise.resolve(results);\n}\n\n/**\n * Calculates the specifc time windows for multiple data fetches required to fetch an entire range\n * @param startTime\n * @param endTime\n * @param intervalObj\n * @param maxBars\n */\nfunction calculateCallTimeWindows(startTime: number,\n                                  endTime: number,\n                                  intervalObj: any,\n                                  maxBars: number): Array<TimeWindow> {\n    //next we want to determine how many calls we need to make to fetch all intervals between start and end time.\n    let windowStart = startTime;\n    let windowEnd = 0;\n    let finalMaxBars = maxBars || defaultMaxBars;\n    let results = [];\n    while (windowStart < endTime) {\n        windowEnd = windowStart + intervalObj.cost * finalMaxBars;\n        results.push({\n            start: windowStart,\n            end: windowEnd\n        });\n        windowStart = windowEnd;\n    }\n    return results;\n}\n\n\nmodule.exports = {\n    fetchCandles\n};"]}